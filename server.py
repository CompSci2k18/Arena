from json import dumps, loads
from random import choice
from select import select
from socket import *
from sys import exit
from threading import Thread
from urllib.request import unquote

"""/*
    Class: ArenaServer
    The threaded server that makes up the back end for the arena
*/"""
class ArenaServer:

    # Types
    """/*
        Type: Tuple
        Python's tuple

        Type: List
        Python's list

        Type: Socket
        Python's socket object from the socket module
    */"""

    # Instance variable docs
    """/*
        String: host
        The address of the host. Generated by this program

        int: port
        The port number the socket will bind to. Default 44444.

        obj: sock
        The socket object the server listens on

        boolean: started
        False while the server is still in the lobby, True once game starts

        boolean: host_start
        False until the host clicks the Start Game button.

        array: players
        List of player JSON objects in the lobby

        int: lobby_size
        Maintaining the amount of players currently in the lobby

        array: coords
        List of <coordinate> tuples players can spawn in

        array: coordinate
        Tuples of (x, y) coordinates

        array: player_objects
        List of the <Player> objects created in Javascript for all players in
        game
    */"""

    """/*
        Constructor: ArenaServer
        Initialises the server and binds it to the host and port specified

        Parameters:
            string host - The host ip of the server. Is usually the local machine
            int port - The port number of the server. Default is 44444
    */"""
    def __init__(self, host, port):
        self.host = host
        self.port = port
        sock = socket(AF_INET, SOCK_STREAM)
        sock.setsockopt(SOL_SOCKET, SO_REUSEADDR, 1)
        sock.bind((self.host, self.port))
        self.sock = sock

        # Game var setup
        self.started = False
        self.host_start = False
        self.players = [None for _ in range(4)]
        self.lobby_size = 0
        width = height = 650
        self.coords = [
            (width / 4, height / 4),
            ((3 * width) / 4, height / 4),
            (width / 4, (3 * height) / 4),
            ((3 * width) / 4, (3 * height) / 4)
        ]
        self.player_objects = []

    """/*
        Function: Close
        Closes the server and releases the socket
    */"""
    def close(self):
        print('Server Closing')
        self.sock.close()

    """/*
        Function: Listen
        Listen for incoming connections and pass them off to the handler methods
        in a new thread
    */"""
    def listen(self):
        self.sock.listen(10)
        print('Lobby Open')
        # Lobby loop
        while not self.started:
            connections, wlist, xlist = select([self.sock], [], [], 0.05)

            for connection in connections:
                client, address = connection.accept()
                client.settimeout(5)
                Thread(
                    target=self._handleLobbyConnection,
                    args=(client, address)).start()
        print('Game Starting')
        while True:  # TODO - Change to end loop when game is over
            connections, wlist, xlist = select([self.sock], [], [], 0.05)

            for connection in connections:
                client, address = connection.accept()
                client.settimeout(10)
                Thread(
                    target=self._handleGameConnection,
                    args=(client, address)).start()

    """/*
        Function: Handle Lobby Connection
        Method run in a separate thread to handle requests while the game is still
        in the lobby state
        
        Parameters:
            Socket client - The socket to send response through.
            Tuple[string, int] address - The address and port of the client.

        Returns:
            The results of <Lobby Join>, <Lobby Query>, or <Lobby Start>,
            depending on the message from the client
    */"""
    def _handleLobbyConnection(self, client, address):
        # Callback on client connection, pass off to correct function
        msg = client.recv(256).decode()
        callback = None
        if 'join' in msg:
            callback = self._lobbyJoin
        elif 'query' in msg:
            callback = self._lobbyQuery
        elif 'start' in msg:
            callback = self._lobbyStart

        if callback:
            callback(client, address, msg)
        client.close()
        return

    """/*
        Function: Lobby Join
        Handler for player joining the lobby

        Parameters:
            Socket client - The socket to send response through
            Tuple[string, int] address - The address and port of the client
            string msg - The msg that was sent by the client
                         Includes the username that the player has chosen

        Returns:
            string response - Either 'lobby full' if the lobby is full, or
                              'joined=' + the index of the player in the array
                              <players>
    */"""
    def _lobbyJoin(self, client, address, msg):
        # Handles players joining the lobby
        if self.lobby_size < 4 and not self.started:
            username = msg.split('=')[1]
            print(username, 'has joined the lobby!')
            # Get the player coords
            player_coords_index = choice(range(len(self.coords)))
            player_coords = self.coords[player_coords_index]
            self.coords.remove(player_coords)
            # Create the player lobby object
            player = {
                'x': player_coords[0],
                'y': player_coords[1],
                'userName': username,
                'colour': '#%s' % (self._generateColour()),
                'local': False,
                'queryTimeout': 20,
                'ready': False
            }
            self.lobby_size += 1
            # Find the index for the player
            for i in range(len(self.players)):
                if self.players[i] == None:
                    break
            self.players[i] = player
            msg = 'joined=' + str(i)
            client.sendall(msg.encode())
        else:
            client.sendall('lobby full'.encode())

    """/*
        Function: Lobby Query
        Handler for AJAX querying the players in the lobby

        Parameters:
            Socket client - The socket to send response through
            Tuple[string, int] address - The address and port of the client
            string msg - The msg that was sent by the client
                         Includes the index of the player in the list of players

        Returns:
            array players - List of player objects currently in the lobby

            boolean started - False if the game hasn't started, True otherwise
    */"""
    def _lobbyQuery(self, client, address, msg):
        # Handles queries against lobby
        player_num = int(msg.split('=')[1])
        self.players[player_num]['queryTimeout'] = 21
        for i in range(len(self.players)):
            player = self.players[i]
            if player != None:
                player['queryTimeout'] -= 1
                if player['queryTimeout'] <= 0:
                    self.coords.append((player['x'], player['y']))
                    self.players[i] = None
                    self.players_in_lobby -= 1
        client.sendall(dumps(
            {'players':
             [player for player in self.players if player is not None],
             'started': self.host_start}).encode())

    """/*
        Function: Lobby Start
        Handler for the host starting the game

        Parameters:
            Socket client - The socket to send response through
            Tuple[string, int] address - The address and port of the client
            string msg - The msg that was sent by the client
                         Includes the index of the player in the list of players

        Returns:
            boolean ready - True if all players in the lobby are ready to
                            start, else False
    */"""
    def _lobbyStart(self, client, address, msg):
        player_num = int(msg.split('=')[1])
        self.players[player_num]['ready'] = True
        # If the server says the host has started, we need to move
        self.host_start = True
        self.started = True
        for player in self.players:
            if player is not None:
                self.started = self.started and player['ready']
        client.sendall(dumps(
            {'ready': self.players[player_num]['ready']}).encode())

    """/*
        Function: Handle Game Connection
        Method run in a separate thread to handle requests while the game is
        running

        Parameters:
            Socket client - The socket to send response through.
            Tuple[string, int] address - The address and port of the client.
            boolean repeat - Due to issues with http sockets, allow one re-run
                             of this handler to ensure message is received

        Returns:
            The results of <Game Start Up> or <Game Update>, depending on the
            message from the client
    */"""
    def _handleGameConnection(self, client, address, repeat=True):
        msg = client.recv(4096).decode()
        callback = None
        if 'start_up' in msg:
            callback = self._gameStartUp
        elif 'update' in msg:
            callback = self._gameUpdate

        if callback:
            callback(client, address, msg)
        elif repeat:
            self._handleGameConnection(client, address, False)
        client.close()
        return

    """/*
        Function: Game Start Up
        Handler for players arriving at the game.html page for syncing up player
        data

        Parameters:
            Socket client - The socket to send response through
            Tuple[string, int] address - The address and port of the client
            string msg - The msg that was sent by the client
                         Includes the index of the player in the list of players

        Returns:
            array players - Starting data for all players, to be turned
                            into <Player> objects in the JavaScript
            boolean ready - True if all players have run this method, else
                            False
    */"""
    def _gameStartUp(self, client, address, msg):
        # Handles players arriving at the game screen
        # Loop through the list of players, setting flags
        player_num = int(unquote(msg.split('start_up=')[1]))
        payload = []
        ready = True
        for i in range(len(self.players)):
            player = self.players[i]
            if player is not None:
                if i == player_num:
                    player['local'] = True
                    player['ready'] = True
                else:
                    player['local'] = False
                ready = ready and player['ready']
                payload.append(player)
        # Send the payload containing only the active players
        data = {'players': payload, 'ready': ready}
        response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nAccess-Control-Allow-Origin: http://cs1.ucc.ie\r\n\r\n"
        response += dumps(data) + '\r\n'
        client.sendall(response.encode())

    """/*
        Function: Game Update
        Handler for the AJAX updating player data for all players connected

        Parameters:
            Socket client - The socket to send response through
            Tuple[string, int] address - The address and port of the client
            string msg - The msg that was sent by the client
                         Includes a JSON string of the local players data

        Returns:
            array players - The current status of all players in the game
    */"""
    def _gameUpdate(self, client, address, msg):
        # Handles game updates on the server
        # MUST BE AS EFFICIENT AS POSSIBLE
        player = loads(unquote(msg.split('update=')[1]))
        try:
            self.player_objects[player['id']] = player
        except IndexError:
            self.player_objects.append(player)
        data = {'players': self.player_objects}
        response = "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\nAccess-Control-Allow-Origin: http://cs1.ucc.ie\r\n\r\n"
        response += dumps(data)
        client.sendall(response.encode())

    """/*
        Function: Generate Colour
        Generate a random colour for a player

        Returns:
            string colour - Random 6-digit hexadecimal string representing a
                            colour value
    */"""
    def _generateColour(self):
        return ''.join([choice('0123456789ABCDEF') for x in range(6)])

if __name__ == '__main__':
    # Set values for localhost
    hostname = gethostname()
    hostip = gethostbyname(hostname)
    port = 44444 # Do not change port if you want to make the server public (Password support coming soon)
    server_address = (hostip, port)
    print('SERVER ADDRESS DETAILS')
    print('PASS THE FOLLOWING TO YOUR FRIENDS')
    print('Address:', hostip)
    print('Port:', port)
    server = ArenaServer(hostip, port)
    try:
        server.listen()
    except KeyboardInterrupt:
        pass
    except Exception as e:
        print(e)
    finally:
        server.close()
